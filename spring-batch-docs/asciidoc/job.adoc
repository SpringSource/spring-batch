:batch-asciidoc: http://docs.spring.io/spring-batch/reference/html/
:toc: left
:toclevels: 4

[[configureJob]]

== Configuring and Running a Job

In the <<domain.adoc#domainLanguageOfBatch,domain section>> , the overall
  architecture design was discussed, using the following diagram as a
  guide:

.Batch Stereotypes
image::{batch-asciidoc}images/spring-batch-reference-model.png[Figure 2.1: Batch Stereotypes, scaledwidth="60%"]

While the `Job` object may seem like a simple
container for steps, there are many configuration options of which a
developers must be aware . Furthermore, there are many considerations for
how a `Job` runs and how its metadata is
stored during a run. This chapter explains the various configuration
options and runtime concerns of a `Job`.

[[configuringAJob]]

=== Configuring a Job

There are multiple implementations of the <<job.adoc#configureJob,`Job`>> interface. However, the namespace
abstracts away the differences in configuration. It has only three
required dependencies: a name, `JobRepository` , and
a list of `Step` implementations. The following example shows a job consisting of three steps:


[source, xml]
----
<job id="footballJob">
    <step id="playerload"          parent="s1" next="gameLoad"/>
    <step id="gameLoad"            parent="s2" next="playerSummarization"/>
    <step id="playerSummarization" parent="s3"/>
</job>
----

The examples in this chapter use a parent bean definition to create the steps.
See the section on <<step.adoc#configureStep, step configuration>>
for more options for declaring specific step details inline. The XML namespace
defaults to referencing a repository with an id of 'jobRepository', which
is a sensible default. However, this can be overridden explicitly, as shown in the following example:


[source, xml]
----
<job id="footballJob" job-repository="specialRepository">
    <step id="playerload"          parent="s1" next="gameLoad"/>
    <step id="gameLoad"            parent="s3" next="playerSummarization"/>
    <step id="playerSummarization" parent="s3"/>
</job>
----

In addition to steps, a job configuration can contain other elements
    that help with parallelization (`<split>`),
    declarative flow control (`<decision>`) and
    externalization of flow definitions
    (`<flow/>`).

[[restartability]]

==== Restartability

One key issue when executing a batch job concerns the behavior of
a `Job` when it is restarted. The launching of a
`Job` is considered to be a 'restart' if a
`JobExecution` already exists for the particular
`JobInstance`. Ideally, all jobs should be able to
start up where they left off, but there are scenarios where this is not
possible. __It is entirely up to the developer to ensure that a new `JobInstance` is created in this scenario__. However, Spring Batch does provide some help. If a
`Job` should never be restarted but should always
be run as part of a new `JobInstance`, then the
restartable property may be set to 'false', as shown in the following example:


[source, xml]
----
<job id="footballJob" restartable="false">
    ...
</job>
----

To phrase it another way, setting restartable to false means "this
`Job` does not support being started again". Restarting a `Job` that is not
restartable causes a `JobRestartException` to
be thrown, as shown in the following example:

[source, java]
----
Job job = new SimpleJob();
job.setRestartable(false);

JobParameters jobParameters = new JobParameters();

JobExecution firstExecution = jobRepository.createJobExecution(job, jobParameters);
jobRepository.saveOrUpdate(firstExecution);

try {
    jobRepository.createJobExecution(job, jobParameters);
    fail();
}
catch (JobRestartException e) {
    // expected
}
----

The preceding snippet of JUnit code shows how attempting to create a
`JobExecution` the first time for a non-restartable
job causes no issues. However, the second
attempt throws a `JobRestartException`.

[[interceptingJobExecution]]

==== Intercepting Job Execution

During the course of the execution of a
Job, it may be useful to be notified of various
events in its lifecycle so that custom code may be executed. The
`SimpleJob` object allows for this by calling a
`JobListener` at the appropriate time, as shown in the following example:

[source, java]
----
public interface JobExecutionListener {

    void beforeJob(JobExecution jobExecution);

    void afterJob(JobExecution jobExecution);

}
----

`JobListeners` can be added to a
`SimpleJob` via the listeners element on the
job:


[source, xml]
----
<job id="footballJob">
    <step id="playerload"          parent="s1" next="gameLoad"/>
    <step id="gameLoad"            parent="s2" next="playerSummarization"/>
    <step id="playerSummarization" parent="s3"/>
    <listeners>
        <listener ref="sampleListener"/>
    </listeners>
</job>
----

It should be noted that `afterJob` is
      called regardless of the success or failure of the
      `Job`. If success or failure needs to be determined,
      it can be obtained from the `JobExecution`, as shown in the following example:


[source, java]
----
public void afterJob(JobExecution jobExecution){
    if( jobExecution.getStatus() == BatchStatus.COMPLETED ){
        //job success
    }
    else if(jobExecution.getStatus() == BatchStatus.FAILED){
        //job failure
    }
}
----

The annotations corresponding to this interface are:


* `@BeforeJob`
* `@AfterJob`

[[inheritingFromAParentJob]]


==== Inheriting from a Parent Job

If a group of `Job` instances share similar but not
      identical configurations, then it may be helpful to define a "parent"
      `Job` from which the concrete
      Jobs may inherit properties. Similar to class
      inheritance in Java, the "child" `Job` combines
      its elements and attributes with the parent's.

In the following example, "baseJob" is an abstract
      `Job` definition that defines only a list of
      listeners. The `Job` called "job1" is a concrete
      definition that inherits the list of listeners from "baseJob" and merges
      it with its own list of listeners to produce a
      `Job` with two listeners and one
      `Step`, called "step1".


[source, xml]
----
<job id="baseJob" abstract="true">
    <listeners>
        <listener ref="listenerOne"/>
    <listeners>
</job>

<job id="job1" parent="baseJob">
    <step id="step1" parent="standaloneStep"/>

    <listeners merge="true">
        <listener ref="listenerTwo"/>
    <listeners>
</job>
----

See the section on <<step.adoc#inheritingFromParentStep,Inheriting from a Parent Step>>
      for more detailed information.



==== `JobParametersValidator`

A job declared in the XML namespace or using any subclass of
      `AbstractJob` can optionally declare a validator for the job parameters at
      runtime. Doing so is useful when, for instance, you need to assert that a job
      is started with all its mandatory parameters. There is a
      `DefaultJobParametersValidator` that can be used to constrain combinations
      of simple mandatory and optional parameters. For more complex
      constraints you can implement the interface yourself. The configuration
      of a validator is supported through the XML namespace through a child
      element of the job, as shown in the following example:


[source, xml]
----
<job id="job1" parent="baseJob3">
    <step id="step1" parent="standaloneStep"/>
    <validator ref="paremetersValidator"/>
</job>
----

The validator can be specified as a reference (as in the preceding snippet) or as a
      nested bean definition in the beans namespace.

[[javaConfig]]


=== Java Config

Spring 3 brought the ability to configure applications with Java instead
  	of XML.  As of Spring Batch 2.2.0, batch jobs can be configured using
  	Java configuration.  There are two components for the Java-based configuration:
  	the `@EnableBatchProcessing` annotation and two builders.

The `@EnableBatchProcessing` annotation works similarly to the other
  	`@Enable*` annotations in the Spring family.  In this case,
  	`@EnableBatchProcessing` provides a base configuration for
  	building batch jobs.  Within this base configuration, an instance of
  	`StepScope` is created and a number of beans made
  	available to be autowired:



* `JobRepository` - bean name "jobRepository"


* `JobLauncher` - bean name "jobLauncher"


* `JobRegistry` - bean name "jobRegistry"


* `PlatformTransactionManager` - bean name "transactionManager"


* `JobBuilderFactory` - bean name "jobBuilders"


* `StepBuilderFactory` - bean name "stepBuilders"

The core interface for this configuration is the `BatchConfigurer`.
    The default implementation provides the beans mentioned above and requires a
    `DataSource` as a bean within the context to be provided.  This data
    source is used by the JobRepository.



[NOTE]
====
Only one configuration class needs to have the
    	`@EnableBatchProcessing` annotation.  Once you have a class
    	annotated with it, you have all of the previousluy mentioned configuration available.

====


With the base configuration in place, a user can use the provided builder factories
	to configure a job.  The following example shows a two-step job configured with
	`JobBuilderFactory` and `StepBuilderFactory`.


[source, java]
----
@Configuration
@EnableBatchProcessing
@Import(DataSourceConfiguration.class)
public class AppConfig {

    @Autowired
    private JobBuilderFactory jobs;

    @Autowired
    private StepBuilderFactory steps;

    @Bean
    public Job job(@Qualifier("step1") Step step1, @Qualifier("step2") Step step2) {
        return jobs.get("myJob").start(step1).next(step2).build();
    }

    @Bean
    protected Step step1(ItemReader<Person> reader, ItemProcessor<Person, Person> processor, ItemWriter<Person> writer) {
        return steps.get("step1")
            .<Person, Person> chunk(10)
            .reader(reader)
            .processor(processor)
            .writer(writer)
            .build();
    }

    @Bean
    protected Step step2(Tasklet tasklet) {
        return steps.get("step2")
            .tasklet(tasklet)
            .build();
    }
}
----

[[configuringJobRepository]]

=== Configuring a `JobRepository`

As described earlier in this chapter, the <<job.adoc#configureJob,`JobRepository`>> is used for basic CRUD operations of the various persisted
    domain objects within Spring Batch, such as
    `JobExecution` and
    `StepExecution`. It is required by many of the major
    framework features, such as the `JobLauncher`,
    `Job`, and `Step`. The batch
    namespace abstracts away many of the implementation details of the
    `JobRepository` implementations and their
    collaborators. However, there are still a few more configuration options
    available, as shown in the following example:


[source, xml]
----
<job-repository id="jobRepository"
    data-source="dataSource"
    transaction-manager="transactionManager"
    isolation-level-for-create="SERIALIZABLE"
    table-prefix="BATCH_"
	max-varchar-length="1000"/>
----

Except for the `id` attribute, none of the configuration options listed in the preceding code are required
    . If they are not set, the defaults shown in the example are used. (They
    are included in the example to make them apparent). The
    `max-varchar-length` defaults to 2500, which is the
    length of the long `VARCHAR` columns in the <<schema-appendix.adoc#metaDataSchemaOverview,sample schema scripts>>.

[[txConfigForJobRepository]]


==== Transaction Configuration for the `JobRepository`

If the namespace is used, transactional advice is
      automatically created around the repository. This is to ensure that the
      batch metadata, including state that is necessary for a restart after a
      failure, is persisted correctly.  If the repository methods are not transactional, the behavior of the framework is not
      well defined. The
      isolation level in the `create*` method attributes is
      specified separately to ensure that, when jobs are launched, if two
      processes are trying to launch the same job at the same time, only one
      succeeds. The default isolation level for that method is
      `SERIALIZABLE`, which is quite aggressive: `READ_COMMITTED` would work just
      as well. `READ_UNCOMMITTED` would be fine if two processes are not likely
      to collide in this way. However, since a call to the
      `create*` method is quite short, it is unlikely
      that the `SERIALIZED` option will cause problems, as long as the database
      platform supports it. However, this can be overridden, as shown in the following example:



[source, xml]
----
<job-repository id="jobRepository"
                isolation-level-for-create="REPEATABLE_READ" />
----




If the namespace or factory beans are not used, then it is also
      essential to configure the transactional behavior of the repository
      using AOP, as shown in the following example:



[source, xml]
----
<aop:config>
    <aop:advisor
           pointcut="execution(* org.springframework.batch.core..*Repository+.*(..))"/>
    <advice-ref="txAdvice" />
</aop:config>

<tx:advice id="txAdvice" transaction-manager="transactionManager">
    <tx:attributes>
        <tx:method name="*" />
    </tx:attributes>
</tx:advice>
----




The preceding fragment can be used as is, with almost no changes. Remember
      to include the appropriate namespace declarations and to make sure
      `spring-tx` and `spring-aop` (or the whole of `spring`) are on the
      classpath.

[[repositoryTablePrefix]]


==== Changing the Table Prefix

Another modifiable property of the
      `JobRepository` is the table prefix of the
      metadata tables. By default, they are all prefaced with `BATCH_`.
      `BATCH_JOB_EXECUTION` and `BATCH_STEP_EXECUTION` are two examples. However,
      there are potential reasons to modify this prefix. If the schema names
      needs to be prepended to the table names, or if more than one set of
      metadata tables is needed within the same schema, then the table prefix
      needs to be changed, as shown in the following example:


[source, xml]
----
<job-repository id="jobRepository"
                table-prefix="SYSTEM.TEST_" />
----

Given the changes in the preceding example, every query to the metadata tables is
      prefixed with `SYSTEM.TEST_`. `BATCH_JOB_EXECUTION` is referred to
      as SYSTEM.`TEST_JOB_EXECUTION`.


[NOTE]
====
Only the table prefix is configurable. The table and column
        names are not configurable.

====


[[inMemoryRepository]]


==== In-Memory Repository

There are scenarios in which you may not want to persist your
      domain objects to the database. One reason may be speed. Storing domain
      objects at each commit point takes extra time. Another reason may be
      that you do not need to persist status for a particular job. For
      this reason, Spring batch provides an in-memory Map version of the job
      repository, as shown in the following example:


[source, xml]
----
<bean id="jobRepository"
  class="org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean">
    <property name="transactionManager" ref="transactionManager"/>
</bean>
----

Note that the in-memory repository is volatile and so does not
      allow restart between JVM instances. It also cannot guarantee that two
      job instances with the same parameters are launched simultaneously. It
      is not suitable for use in a multi-threaded Job or a locally
      partitioned `Step`. Use the database version of the repository wherever
      you need those features.

However, the in-memory repository does require a transaction manager to be defined,
      because there are rollback semantics within the repository and because
      the business logic might still be transactional (for example, to support RDBMS access). For
      testing purposes, many people find the
      `ResourcelessTransactionManager` useful.

[[nonStandardDatabaseTypesInRepository]]


==== Non-standard Database Types in a Repository

If you are using a database platform that is not in the list of
      supported platforms, you may be able to use one of the supported types,
      if the SQL variant is close enough. To do this you can use the raw
      `JobRepositoryFactoryBean` instead of the namespace
      shortcut and use it to set the database type to the closest
      match, as shown in the following example:


[source, xml]
----
<bean id="jobRepository" class="org...JobRepositoryFactoryBean">
    <property name="databaseType" value="db2"/>
    <property name="dataSource" ref="dataSource"/>
</bean>
----

The `JobRepositoryFactoryBean` tries to
      auto-detect the database type from the `DataSource`
      if it is not specified. The major differences between platforms are
      mainly accounted for by the strategy for incrementing primary keys, so
      often it might be necessary to override the
      `incrementerFactory` as well (using one of the standard
      implementations from the Spring Framework).

If even that does not work or you are not using an RDBMS, then the
      only option may be to implement the various `Dao`
      interfaces that the `SimpleJobRepository` depends
      on and create one manually in the normal Spring way.
      // TODO Add a link to the "normal Spring way," if possible.

[[configuringJobLauncher]]


=== Configuring a `JobLauncher`

The most basic implementation of the
    `JobLauncher` interface is the
    `SimpleJobLauncher`. Its only required dependency is
    a JobRepository, in order to obtain an
    execution, as shown in the following example:


[source, xml]
----
<bean id="jobLauncher"
      class="org.springframework.batch.core.launch.support.SimpleJobLauncher">
    <property name="jobRepository" ref="jobRepository" />
</bean>
----

Once a <<domain.adoc#domainLanguageOfBatch,`JobExecution`>> is
    obtained, it is passed to the execute method of
    Job, ultimately returning the
    `JobExecution` to the caller, as shown in the following image:

.Job Launcher Sequence
image::{batch-asciidoc}images/job-launcher-sequence-sync.png[Job Launcher Sequence, scaledwidth="60%"]

The sequence is straightforward and works well when launched from a
    scheduler. However, issues arise when trying to launch from an HTTP
    request. In this scenario, the launching needs to be done asynchronously,
    so that the `SimpleJobLauncher` returns immediately
    to its caller. This is because it is not good practice to keep an HTTP
    request open for the amount of time needed by long running processes such
    as a batch job. The following image shows an example sequence:

.Asynchronous Job Launcher Sequence
image::{batch-asciidoc}images/job-launcher-sequence-async.png[Async Job Launcher Sequence, scaledwidth="60%"]


The `SimpleJobLauncher` can easily be
    configured to allow for this scenario by configuring a
    `TaskExecutor`:

[source, xml]
----
<bean id="jobLauncher"
      class="org.springframework.batch.core.launch.support.SimpleJobLauncher">
    <property name="jobRepository" ref="jobRepository" />
    <property name="taskExecutor">
        <bean class="org.springframework.core.task.SimpleAsyncTaskExecutor" />
    </property>
</bean>
----

Any implementation of the spring `TaskExecutor`
    interface can be used to control how jobs are asynchronously
    executed.

[[runningAJob]]


=== Running a Job

At a minimum, launching a batch job requires two things: the
    `Job` to be launched and a
    `JobLauncher`. Both can be contained within the same
    context or different contexts. For example, if launching a job from the
    command line, a new JVM is instantiated for each Job. Thus, every
    job has its own `JobLauncher`. However, if
    running from within a web container within the scope of an
    `HttpRequest`, there is usually one
    `JobLauncher`, configured for asynchronous job
    launching, that multiple requests invoke to launch their jobs.

[[runningJobsFromCommandLine]]


==== Running Jobs from the Command Line

For users who want to run their jobs from an enterprise
      scheduler, the command line is the primary interface. This is because
      most schedulers (with the exception of Quartz unless using
      `NativeJob`) work directly with operating system
      processes, primarily kicked off with shell scripts. There are many ways
      to launch a Java process besides a shell script, such as Perl, Ruby, or
      even 'build tools' such as ant or maven. However, because most people
      are familiar with shell scripts, this example focuses on them.

[[commandLineJobRunner]]


===== The `CommandLineJobRunner`

Because the script launching the job must kick off a Java
        Virtual Machine, there needs to be a class with a `main` method to act
        as the primary entry point. Spring Batch provides an implementation
        that serves this purpose:
        `CommandLineJobRunner`. Note
        that this is just one way to bootstrap your application. There are
        many ways to launch a Java process, and this class should in no way be
        viewed as definitive. The `CommandLineJobRunner`
        performs four tasks:


* Load the appropriate
            ApplicationContext.


* Parse command line arguments into
            JobParameters.


* Locate the appropriate job based on arguments.


* Use the `JobLauncher` provided in the
            application context to launch the job.

All of these tasks are accomplished with only the arguments
        passed in. The following table describes the required arguments:

.CommandLineJobRunner arguments

|===============
|jobPath|The location of the XML file used to
                create an ApplicationContext. This file
                should contain everything needed to run the complete
                `Job`.
|jobName|The name of the job to be run.

|===============


The arguments must be passed in with the path first and the
        name second. All arguments after these are considered to be
        JobParameters and must be in the format of 'name=value', as shown in the following example:


[source]
----
<bash$ java CommandLineJobRunner endOfDayJob.xml endOfDay schedule.date(date)=2007/05/05
----

In most cases, you would want to use a manifest to declare your
        `main` class in a jar, but, for simplicity, the class in the following example is used directly.
        This example uses the same 'EndOfDay' example from the <<domain.adoc#domainLanguageOfBatch,Domain Language Of Batch chapter>>. The first argument is
        'endOfDayJob.xml', which is the Spring
        `ApplicationContext` containing the
        `Job`. The second argument, 'endOfDay' represents
        the job name. The final argument, 'schedule.date(date)=20017/05/22'
        is converted into a `JobParameters` object. An
        example of the XML configuration follows:


[source, xml]
----
<job id="endOfDay">
    <step id="step1" parent="simpleStep" />
</job>

<!-- Launcher details removed for clarity -->
<beans:bean id="jobLauncher"
         class="org.springframework.batch.core.launch.support.SimpleJobLauncher" />
----

The preceding example is overly simplistic, since there are nearly always many more
        requirements to a run a batch job in Spring Batch, but it
        shows the two main requirements of the
        `CommandLineJobRunner`:
        `Job` and
        `JobLauncher`.

[[exitCodes]]


===== Exit Codes

When launching a batch job from the command line, an enterprise
        scheduler is often used. Most schedulers are fairly dumb and work only
        at the process level. This means that they only know about some
        operating system process, such as a shell script, that they invoke.
        In this scenario, the only way to communicate back to the scheduler
        about the success or failure of a job is through return codes. A
        return code is a number that is returned to a scheduler by the process
        that indicates the result of the run. In the simplest case, 0 is
        success, and 1 is failure. However, there may be more complex
        scenarios. For example, you might have logic such as "if job A returns 4, kick off job B or, if it returns 5, kick
        off job C." This type of behavior is configured at the scheduler level,
        but it is important that a processing framework such as Spring Batch
        provide a way to return a numeric representation of the "Exit Code"
        for a particular batch job. In Spring Batch this is encapsulated
        within an `ExitStatus`, which is covered in more
        detail in <<step.adoc#batchStatusVsExitStatus,Chapter 5>>. For the purposes of discussing exit codes, the
        only important thing to know is that an
        `ExitStatus` has an exit code property that is
        set by the framework (or the developer) and is returned as part of the
        `JobExecution` returned from the
        `JobLauncher`. The
        `CommandLineJobRunner` converts this string value
        to a number using the ExitCodeMapper
        interface, as shown in the following example:


[source, java]
----
public interface ExitCodeMapper {

    public int intValue(String exitCode);

}
----

The essential contract of an
        `ExitCodeMapper` is that, given a string exit
        code, a number representation is returned. The default
        implementation used by the job runner is the `SimpleJvmExitCodeMapper`
        that returns 0 for completion, 1 for generic errors, and 2 for any job
        runner errors, such as not being able to find a
        `Job` in the provided context. If anything more
        complex than the 3 values above is needed, then a custom
        implementation of the `ExitCodeMapper` interface
        must be supplied. Because the
        `CommandLineJobRunner` is the class that creates
        an `ApplicationContext` and cannot be
        "wired together", any values that need to be overwritten must be
        autowired. This means that if an implementation of
        `ExitCodeMapper` is found within the `BeanFactory`,
        it is injected into the runner after the context is created. All
        you need to do to provide your own
        `ExitCodeMapper` is to declare the implementation
        as a root level bean and ensure that it is part of the
        `ApplicationContext` that is loaded by the
        runner.
        // TODO What do we mean by "wired together"?

[[runningJobsFromWebContainer]]


==== Running Jobs from within a Web Container

Historically, offline processing, such as batch jobs, has been
      launched from the command-line, as described above. However, there are
      many cases where launching from an `HttpRequest` is
      a better option. Many such use cases include reporting, ad-hoc job
      running, and web application support. Because a batch job, by definition,
      is long running, the most important concern is ensuring to launch the
      job asynchronously, as shown in the following image:

.Asynchronous Job Launcher Sequence From Web Container
image::{batch-asciidoc}images/launch-from-request.png[Async Job Launcher Sequence from web container, scaledwidth="60%"]


The controller in this case is a Spring MVC controller. More
      information on Spring MVC can be found at link:$$http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html$$[http://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html].
      The controller launches a `Job` using a
      `JobLauncher` that has been configured to launch
      <<job.adoc#runningJobsFromWebContainer,asynchronously>>, which
      immediately returns a `JobExecution`. The
      `Job` is likely still running. However, this
      nonblocking behavior allows the controller to return immediately, which
      is required when handling an `HttpRequest`. An
      example follows:


[source, java]
----
@Controller
public class JobLauncherController {

    @Autowired
    JobLauncher jobLauncher;

    @Autowired
    Job job;

    @RequestMapping("/jobLauncher.html")
    public void handle() throws Exception{
        jobLauncher.run(job, new JobParameters());
    }
}
----

[[advancedMetaData]]


=== Advanced Metadata Usage

So far, both the `JobLauncher` and `JobRepository` interfaces have been
    discussed. Together, they represent the simple launching of a job and basic
    CRUD operations of batch domain objects, as shown in the following image:

.Job Repository
image::{batch-asciidoc}images/job-repository.png[Job Repository, scaledwidth="60%"]

A `JobLauncher` uses the
    `JobRepository` to create new
    `JobExecution` objects and run them.
    `Job` and `Step` implementations
    later use the same `JobRepository` for basic updates
    of the same executions during the running of a `Job`.
    The basic operations suffice for simple scenarios, but, in a large batch
    environment with hundreds of batch jobs and complex scheduling
    requirements, more advanced use of the metadata is required, as shown in the following image:

.Advanced Job Repository Access
image::{batch-asciidoc}images/job-repository-advanced.png[Job Repository Advanced, scaledwidth="80%"]

The `JobExplorer` and
    `JobOperator` interfaces, which are discussed
    later in this chapter, add additional functionality for querying and controlling the metadata.

[[queryingRepository]]


==== Querying the Repository

The most basic need before any advanced features is the ability to
      query the repository for existing executions. This functionality is
      provided by the JobExplorer interface, as shown in the following example:


[source, java]
----
public interface JobExplorer {

    List<JobInstance> getJobInstances(String jobName, int start, int count);

    JobExecution getJobExecution(Long executionId);

    StepExecution getStepExecution(Long jobExecutionId, Long stepExecutionId);

    JobInstance getJobInstance(Long instanceId);

    List<JobExecution> getJobExecutions(JobInstance jobInstance);

    Set<JobExecution> findRunningJobExecutions(String jobName);
}
----

As is evident from the method signatures above,
      `JobExplorer` is a read-only version of the
      `JobRepository`, and, like the
      `JobRepository`, it can be easily configured by a
      factory bean, as shown in the following example:


[source, xml]
----
<bean id="jobExplorer" class="org.spr...JobExplorerFactoryBean"
      p:dataSource-ref="dataSource" />
----

<<job.adoc#repositoryTablePrefix,Earlier in this chapter>>, it was mentioned that the table prefix of the
      `JobRepository` can be modified to allow for
      different versions or schemas. Because the
      `JobExplorer` is working with the same tables, it
      too needs the ability to set a prefix, as shown in the following example:


[source, xml]
----
<bean id="jobExplorer" class="org.spr...JobExplorerFactoryBean"
----



==== `JobRegistry`

A `JobRegistry` (and its parent interface, `JobLocator`) is not
      mandatory, but it can be useful if you want to keep track of which jobs
      are available in the context. It is also useful for collecting jobs
      centrally in an application context when they have been created
      elsewhere (such as in child contexts). Custom `JobRegistry` implementations
      can also be used to manipulate the names and other properties of the
      jobs that are registered. There is only one implementation provided by
      the framework and this is based on a simple map from job name to job
      instance. It is configured as shown in the following example:


[source, xml]
----
<bean id="jobRegistry" class="org.spr...MapJobRegistry" p:dataSource-ref="dataSource" p:tablePrefix="BATCH_"/>
----

There are two ways to populate a `JobRegistry` automatically: By using
      a bean post processor and by using a registrar lifecycle component. These
      two mechanisms are described in the following sections.

===== `JobRegistryBeanPostProcessor`

This is a bean post-processor that can register all jobs as they
        are created, as shown in the following example:


[source, xml]
----
<bean id="jobRegistryBeanPostProcessor" class="org.spr...JobRegistryBeanPostProcessor">
    <property name="jobRegistry" ref="jobRegistry"/>
</bean>
----

Athough it is not strictly necessary, the post-processor in the preceding
        example has been given an `id` attribured so that it can be included in child
        contexts (for example, as a parent bean definition) and cause all jobs created
        there to also be regsistered automatically.



===== `AutomaticJobRegistrar`

This is a lifecycle component that creates child contexts and
        registers jobs from those contexts as they are created. One advantage
        of doing so is that, while the job names in the child contexts still
        have to be globally unique in the registry, their dependencies can
        have "natural" names. For example, you can create a set of XML
        configuration files, each having only one `Job`,
        but all having different definitions of an
        `ItemReader` with the same bean name, such as
        "reader". If all those files were imported into the same context, the
        reader definitions would clash and override one another, but, with the
        automatic registrar this is avoided. This mechanism makes it easier to
        integrate jobs contributed from separate modules of an
        application.


[source, xml]
----
<bean class="org.spr...AutomaticJobRegistrar">
   <property name="applicationContextFactories">
      <bean class="org.spr...ClasspathXmlApplicationContextsFactoryBean">
         <property name="resources" value="classpath*:/config/job*.xml" />
      </bean>
   </property>
   <property name="jobLoader">
      <bean class="org.spr...DefaultJobLoader">
         <property name="jobRegistry" ref="jobRegistry" />
      </bean>
   </property>
</bean>
----

The registrar has two mandatory properties. One is an array of
        `ApplicationContextFactory` (here created from a
        convenient factory bean), and the other is a
        `JobLoader`. The `JobLoader`
        is responsible for managing the lifecycle of the child contexts and
        registering jobs in the JobRegistry.

The `ApplicationContextFactory` is
        responsible for creating the child context and the most common usage
        is as above, using a
        `ClassPathXmlApplicationContextFactory`. One of
        the features of this factory is that, by default, it copies some of the
        configuration down from the parent context to the child. So, for
        instance, you need not redefine the
        `PropertyPlaceholderConfigurer` or AOP
        configuration in the child, if it should happen to be the same as the
        parent.

The `AutomaticJobRegistrar` can be used in
        conjunction with a `JobRegistryBeanPostProcessor`
        if desired (as long as the `DefaultJobLoader` is
        used as well). For instance, this might be desirable if there are jobs
        defined in the main parent context as well as in the child
        contexts.

[[JobOperator]]


==== `JobOperator`

As previously discussed, the `JobRepository`
      provides CRUD operations on the metadata, and the
      JobExplorer provides read-only operations on the
      metadata. However, those operations are most useful when used together
      to perform common monitoring tasks such as stopping, restarting, or
      summarizing a Job, as is commonly done by batch operators. Spring Batch
      provides for these types of operations via the
      `JobOperator` interface, as shown in the following code listing:


[source, java]
----
public interface JobOperator {

    List<Long> getExecutions(long instanceId) throws NoSuchJobInstanceException;

    List<Long> getJobInstances(String jobName, int start, int count)
          throws NoSuchJobException;

    Set<Long> getRunningExecutions(String jobName) throws NoSuchJobException;

    String getParameters(long executionId) throws NoSuchJobExecutionException;

    Long start(String jobName, String parameters)
          throws NoSuchJobException, JobInstanceAlreadyExistsException;

    Long restart(long executionId)
          throws JobInstanceAlreadyCompleteException, NoSuchJobExecutionException,
                  NoSuchJobException, JobRestartException;

    Long startNextInstance(String jobName)
          throws NoSuchJobException, JobParametersNotFoundException, JobRestartException,
                 JobExecutionAlreadyRunningException, JobInstanceAlreadyCompleteException;

    boolean stop(long executionId)
          throws NoSuchJobExecutionException, JobExecutionNotRunningException;

    String getSummary(long executionId) throws NoSuchJobExecutionException;

    Map<Long, String> getStepExecutionSummaries(long executionId)
          throws NoSuchJobExecutionException;

    Set<String> getJobNames();

}
----

The operations shown in the preceding code represent methods from many different
      interfaces, such as `JobLauncher`,
      `JobRepository`,
      `JobExplorer`, and
      `JobRegistry`. For this reason, the provided
      implementation of `JobOperator`,
      `SimpleJobOperator`, has many dependencies, as shown in the following bean definition:


[source, xml]
----
<bean id="jobOperator" class="org.spr...SimpleJobOperator">
    <property name="jobExplorer">
        <bean class="org.spr...JobExplorerFactoryBean">
            <property name="dataSource" ref="dataSource" />
        </bean>
    </property>
    <property name="jobRepository" ref="jobRepository" />
    <property name="jobRegistry" ref="jobRegistry" />
    <property name="jobLauncher" ref="jobLauncher" />
</bean>
----


[NOTE]
====

If you set the table prefix on the job repository, remember to set it on the job explorer as well.
====


[[JobParametersIncrementer]]


==== `JobParametersIncrementer`

Most of the methods on `JobOperator` are
      self-explanatory, and more detailed explanations can be found at
      link:$$http://docs.spring.io/spring-batch/apidocs/org/springframework/batch/core/launch/JobOperator.html$$[javadoc of the interface]. However, the
      `startNextInstance` method is worth noting. This
      method always starts a new instance of a `Job`.
      This can be extremely useful if there are serious issues in a
      `JobExecution` and the `Job`
      needs to be started over again from the beginning. However, unlike
      `JobLauncher` (which requires a new
      `JobParameters` object that triggers a new
      `JobInstance` if the parameters are different from
      any previous set of parameters), the
      `startNextInstance` method uses the
      `JobParametersIncrementer` tied to the
      `Job` to force the `Job` to a
      new instance, as shown in the following example:


[source, java]
----
public interface JobParametersIncrementer {

    JobParameters getNext(JobParameters parameters);

}
----

The contract of `JobParametersIncrementer` is
      that, given a <<job.adoc#jobParameters,`JobParameters`>>
      object, it returns the 'next' `JobParameters`
      object by incrementing any necessary values it may contain. This
      strategy is useful because the framework has no way of knowing what
      changes to the `JobParameters` make it the 'next'
      instance. For example, if the only value in
      `JobParameters` is a date, and the next instance
      should be created, should that value be incremented by one day? Or one
      week (if the job is weekly, for instance)? The same can be said for any
      numerical values that help to identify the Job,
      as shown in the following example:


[source, java]
----
public class SampleIncrementer implements JobParametersIncrementer {

    public JobParameters getNext(JobParameters parameters) {
        if (parameters==null || parameters.isEmpty()) {
            return new JobParametersBuilder().addLong("run.id", 1L).toJobParameters();
        }
        long id = parameters.getLong("run.id",1L) + 1;
        return new JobParametersBuilder().addLong("run.id", id).toJobParameters();
    }
}
----

In this example, the value with a key of 'run.id' is used to
      discriminate between `JobInstances`. If the
      `JobParameters` passed in is `null`, it can be
      assumed that the `Job` has never been run before,
      and, thus, its initial state can be returned. However, if not, the old
      value is obtained, incremented by one, and returned. An incrementer can
      be associated with `Job` by using the 'incrementer'
      attribute in the namespace, as shown in the following example:


[source, xml]
----
<job id="footballJob" incrementer="sampleIncrementer">
    ...
</job>
----

[[stoppingAJob]]


==== Stopping a Job

One of the most common use cases of
      `JobOperator` is gracefully stopping a
      `Job:`


[source, java]
----
Set<Long> executions = jobOperator.getRunningExecutions("sampleJob");
jobOperator.stop(executions.iterator().next());
----

The shutdown is not immediate, since there is no way to force
      immediate shutdown, especially if the execution is currently in
      developer code that the framework has no control over, such as a
      business service. However, as soon as control is returned back to the
      framework, it sets the status of the current
      `StepExecution` to
      `BatchStatus.STOPPED`, saves it, and then does the same
      for the `JobExecution` before finishing.



==== Aborting a Job

A job execution which has a status of `FAILED` can be
      restarted (if the `Job` is restartable). A job execution whose status is
      `ABANDONED` can not be restarted by the framework.
      The `ABANDONED` status is also used in step
      executions to mark them as skippable in a restarted job execution: If a
      job is executing and encounters a step that has been marked
      `ABANDONED` in the previous failed job execution, execution
      moves on to the next step (as determined by the job flow definition
      and the step execution exit status).

If the process died (`"kill -9"` or server
      failure) the job is, of course, not running, but the `JobRepository` has
      no way of knowing because no-one told it before the process died. You
      have to tell it manually that you know that the execution either failed
      or should be considered aborted (by changing its status to
      `FAILED` or `ABANDONED`). It's
      a business decision and there is no way to automate it. Change the
      status to `FAILED` only if it is not restartable or if
      you know the restart data is invalid. There is a utility in Spring Batch
      Admin, called `JobService`, to abort a job execution.
